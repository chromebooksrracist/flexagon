[meta title:"New Flexes" description:"How to define flexes with pat notation" /]

[Header
  title:"New Flexes"
  subtitle:"How to define flexes with pat notation"
  author:"Scott Sherman"
  authorLink:"http://loki3.com/flex" /]


[Aside]
  [var name:'defaultColors' value:`[0x2E4172, 0x2B803E, 0xAA4439, 0x622870, 0xffff00, 0x553900, 0xdddddd, 0x999999]` /]
  [derived name:'initial' value:`[
    {searchFlexes: "ShSh'T1T1'FF'"},
    {flexAndColor: { flexes: 'T1*>Sh*>T2*>>Sh*^', colors:defaultColors }},
    ]` /]
  [Flexagon width:350 height:300 numPats:7 initialScript:initial options:`{structure:true, showIds:false}` /]
[/Aside]

Why can you apply a flex in one place and not another?
How does the flexagon simulator know where flexes can be performed?
How does it know how the flexagon changes when you do a flex?

Have you looked at the funny notation along the edges of the flexagon in the simulator and wondered what it means?
Perhaps you noticed that `-` is next to a triangle containing only a single leaf
and `[- -]` is next to a pair of leaves folded on top of each other.
But then you saw `[[[- [- -]] -] -]` and figured it was too complex to worry about.

Well, that notation describes the internal structure of the flexagon,
and it's exactly that structure that determines where you can do a particular flex.
Understanding that internal structure is key to understanding how a flex rearranges the leaves in a flexagon.


# Pat notation

* **Leaf**: Each individual polygon in an unfolded flexagon
* **Pat**: A stack of leaves in a folded flexagon

For example, a hexaflexagon consists of 6 pats, where each pat contains 1 or more leaves.
Every leaf is connected to exactly two other leaves in a folded flexagon, and every pat is connected to exactly two adjacent pats.

* **Pat notation**: Notation used to describe how leaves are folded in a triangle flexagon, consisting of pairs of leaves and/or subpats

The flexagon simulator uses `-` to represent a generic leaf,
which is sufficient for understanding how the folds in a pat are nested.
But a more precise notation starts by uniquely labeling every leaf and using those labels, which helps when defining how flexes work.

Enough talk.
Let's see what this actually looks like.
Below are unfolded strips for all the different ways to fold a pat with 2, 3, or 4 leaves.

[Aside]
Cut out each of the strips and assemble them by folding the highest pair of numbers together,
then the next highest together and so on until you have a single pat.

Note that turning over `1`, `2`, and `4b` gives you the same nesting structure,
but turning over `3`, `4a`, and `4c` gives you a different nesting of leaves.
Thus there are actually 9 different leaf arrangements for pats with 1, 2, 3, or 4 leaves in them:
`1`, `2`, `3`, `-3`, `4a`, `-4a`, `4b`, `4c`, and `-4c`.
[/Aside]

2: [Unfolded width:250 height:100 options:`{end:1, rotation:60, captions:[{text:'2', which:0}]}`
  script:`[ {pats:[[1, 2], 100]}, {angles:[60,60]} ]` /]
3: [Unfolded width:300 height:100 options:`{end:2, captions:[{text:'3', which:0}]}`
  script:`[ {pats:[[1, [2, 3]], 100]}, {angles:[60,60]} ]` /]

[Float position:'right']
  4c: [Unfolded width:250 height:200 options:`{end:3, rotation:60, captions:[{text:'4c', which:0}]}`
    script:`[ {pats:[[1, [[2, 3], 4]], 100]}, {angles:[60,60]} ]` /]
[/Float]

4a: [Unfolded width:300 height:100 options:`{end:3, captions:[{text:'4a', which:0}]}`
  script:`[ {pats:[[[[1, 2], 3], 4], 100]}, {angles:[60,60]} ]` /]

4b: [Unfolded width:300 height:100 options:`{end:3, captions:[{text:'4b', which:0}]}`
  script:`[ {pats:[[[1, 2], [3, 4]], 100]}, {angles:[60,60]} ]` /]

[Aside]
  [img src:'static/4a.png' /]
[/Aside]

If you fold those sample pats and look at the results,
you'll note that the hinges between triangles can occur at any of the three edges.
But, it turns out that we don't have to model that detail in order to capture the important structure.
The important part is how the hinges are nested.
If you know the nesting and which leaves connect to adjacent pats,
you can infer which of the three edges the hinge connects.

The adjacent picture gives you an exploded view of what the nesting looks like for `4a`.
The 4 triangles represent the 4 leaves in the pat, and the colored pieces indicate where the hinges are.
The blue coming in from the bottom left connects to the pat to the left.
The green hinge connects the bottom leaf along the back to the leaf a couple steps up.
The red hinge on the right connects that leaf to the top leaf,
and the hinge on the left connects the top leaf to the leaf a couple steps below.
Finally, the blue on the right connects to the pat on the right.


Pat notation groups leaves and subpats together by how they're nested.
A single leaf is `-`.
Two leaves folded together is `[- -]`.
If you fold a leaf and a 2-pat together, you either get `[- [- -]]` or `[[- -] -]`,
depending on the order of the two pieces.

When tracking how the internals of a flexagon change during a flex, we need to be able to track each leaf,
so we label every leaf with a unique id.
If our labels are numbers, one side can be positive and the flip side negative.
Thus we could describe 4a as `[[[3, -2], -4], 1]` or `[[[1, 2], 3], 4]`, depending on our choice of labels.

Using this, we can describe the 9 different ways to assemble pats with 4 or fewer leaves.
The following assumes the leaves are labeled in the order they occur in the unfolded strip.

[Float position:'left']
* 1: `1`
* 3: `[[-2, 3], 1]`
* 4a: `[[[3, -2], -4], 1]`
* 4b: `[[3, -4], [1, -2]]`
* -4c: `[-4, [[-2, 1], 3]]`
[/Float]

[Float position:'right']
* 2: `[-2, 1]`
* -3: `[3, [1, -2]]`
* -4a: `[-4, [1, [3, -2]]]`
* 4c: `[[-2, [-4, 3]], 1]`
[/Float]
.

To describe an entire flexagon, you simply string together the descriptions of each pat, going clockwise around the flexagon.
So a 3-sided hexaflexagon might look like `[[1, 2], 3, [4, 5], 6, [7, 8], 9]`.
And to describe the effect of a flex, you describe the state before the flex and after the flex.

But how can you use this to *predict* what a flex will do rather than simply recording what it did *after* you do the flex?

# Defining a flex

Here's the definition of the pinch flex on a hexaflexagon using pat notation:

* before: `[[-2, 1], -3, [5, -4], 6, [-8, 7], -9]`
* after: `[2, [-4, 3], -5, [7, -6], 8, [1, 9]]`

This tells us both *if* we can do the pinch flex in a particular location
and *how it would change the flexagon* if we actually do a pinch flex.

It says that the first pat must have at least 2 leaves,
the second pat can be anything (since pats must have at least 1 leaf),
the third pat must have at least 2 leaves, etc.
So if our current flexagon looks like `[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]`, we can do a pinch flex,
but if it's `[1, 2, [3, 4], 5, [6, 7], 8]`, we can't.


# Creating a new flex


# More details

The nesting structure we've been using captures *almost* everything you need to understand where you can perform a flex.
But there are a few missing details.

1. Where a pat connects to adjacent pats
2. If the structure suports any additional freedom that's needed in order to perform the flex
3. Whether the angles along the edges of the flexagon allow the flex

## 1. How pats are connected and rotated

When a flexagon is made up of triangles with 2 or 3 different angles,
you may have noticed that some flexes rotate the pats so that a different angle is in the center of the flexagon.
To fully capture the behavior of flexing, you need to know how the pats are rotated or flipped.

* Some flexes that don't affect rotation: `^`, `T`, `Sh`, `F`, `St`, `Lk`, `Ltf`, `L3`, `P333`, `P334`
* Some flexes that mirror the pats: `>`, `<`
* Some flexes that mirror and rotate pats: `P`, `V`, `Lh`, `Ltb`, `Lbf`, `Lbb`

This effect is most noticeable when the angles of the triangles are unequal or if you decorate the leaves assymetrically.
In the following flexagon, you'll notice that it no longer lies flat after doing a pinch flex,
but the tuck and pyramid shuffle don't affect how the triangles are rotated.

// this comment works around a bug
[Flexagon width:400 height:400 numPats:10 options:`{showIds:false, structure:true, stats:true}`
  initialScript:`[{angles:[36,54]}, {flexes:"P+>>T1+>Sh+"}, {searchFlexes:"PShSh'T1T1'"}]` /]

[Unfolded width:1000 height:350 numPats:10 generator:"P+>>T1+>Sh+" /]

## 2. Additional needed structure

Some flexes need additional structure in order to provide enough freedom to perform a flex,
even if that additional structure isn't otherwise affected by the flex.

The tuck flex provides a good example of this.
If you only write out pat notation for the part of the flexagon that changes, you get the following:

* before: `[[[-2, 3], 1], 4, 5, 6, 7, 8]`
* after: `[3, 4, 5, 6, 7, [2, [8, -1]]]`

[Unfolded width:600 height:280 numPats:6 generator:'Tf+>' endText:'Tf' /]

If you make that flexagon, you'll find that you can't actually flex it,
unless you're willing to really force it and do some damage to the flexagon, or perhaps trim the leaves.
This is because when you're doing the flex, you need to open it somewhere across from where you're doing the tuck
in order to have enough freedom of movement.

Here's what it looks like when you add in the extra flap (`[-7, 6]`) you need in order to open up the flexagon:

* before: `[[[-2, 3], 1], 4, 5, [-7, 6], -8, -9]`
* after: `[3, 4, 5, [-7, 6], -8, [2, [-9, -1]]]`

[Unfolded width:600 height:350 numPats:6 generator:'T+' endText:'T' /]

On flexagons with more than 6 pats, there may be multiple places you could add an extra flap to support the tuck flex.
In *flexagonator*, the flexagon simulator, this is captured by specifying multiple tuck variants:
`T1` if the flap is in one place, `T2` if it's in another, etc.
This isn't ideal for general flexing, since they're actually all the same flex.
But it's good for generating sequences because you have to be explicit about where new leaves were added.

That first flex is called the `forced tuck`, or `Tf`.
It can be useful when trying to explore every possible state for a given flexagon,
but otherwise isn't a practical flex.

## 3. Angles along the edges

Some flexes only work if the angles of the triangles are within a certain fuzzy range.
Once you start going beyond that range, it gets harder to do the flex without damaging the flexagon.

A good example of this is the flip flex.
On some flexagons, like a hexaflexagon made of 30-60-90 triangles,
it's an elegant flex at one vertex but practically impossible at the vertex right next to it.

// this comment prevents an odd bug where the buttons appear in the wrong place
[Flexagon width:400 height:400 numPats:6 options:`{showIds:false, structure:true}`
  initialScript:`[{angles:[60,30]}, {flexes:"F+>F+"}, {searchFlexes:"FF'"}]` /]

[Unfolded width:1000 height:400 numPats:6 generator:"F+>F+" endText:"F+>F+" options:`{rotation:120}` /]

Note that flexagonator doesn't know when the angles have gone beyond the acceptable range,
so it will allow you to perform flexes in places where a physical model may not.


[hr /]

# What next?

This only describes the pats in a *triangle* flexagon.
What about flexagons made from squares or other quadrilaterals?
What about pentagons, hexagons, etc.?

For additional information, see [loki3.com](http://loki3.com/flex/).

[FullWidth]
  [img src:'static/flexagon-variety.jpg' /]
[/FullWidth]
